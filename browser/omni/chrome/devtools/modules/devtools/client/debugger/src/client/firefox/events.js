"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeEventsTopTarget = removeEventsTopTarget;
exports.setupEvents = setupEvents;
exports.setupEventsTopTarget = setupEventsTopTarget;
exports.addThreadEventListeners = addThreadEventListeners;
exports.attachAllTargets = attachAllTargets;
exports.clientEvents = void 0;

var _actions = _interopRequireDefault(require("../../actions/index"));

loader.lazyRequireGetter(this, "_create", "devtools/client/debugger/src/client/firefox/create");

var _sourceQueue = _interopRequireDefault(require("../../utils/source-queue"));

loader.lazyRequireGetter(this, "_telemetry", "devtools/client/debugger/src/utils/telemetry");
loader.lazyRequireGetter(this, "_prefs", "devtools/client/debugger/src/utils/prefs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at <http://mozilla.org/MPL/2.0/>. */
const {
  WorkersListener // $FlowIgnore

} = require("devtools/client/shared/workers-listener.js");

let actions;
let isInterrupted;
let threadFrontListeners;
let workersListener;

function addThreadEventListeners(thread) {
  const removeListeners = [];
  Object.keys(clientEvents).forEach(eventName => {
    // EventEmitter.on returns a function that removes the event listener.
    removeListeners.push(thread.on(eventName, clientEvents[eventName].bind(null, thread)));
  });
  threadFrontListeners.set(thread, removeListeners);
}

function removeThreadEventListeners(thread) {
  const removeListeners = threadFrontListeners.get(thread) || [];

  for (const removeListener of removeListeners) {
    removeListener();
  }
}

function attachAllTargets(currentTarget) {
  return _prefs.prefs.fission && currentTarget.isParentProcess;
}

function setupEvents(dependencies) {
  const {
    debuggerClient
  } = dependencies;
  actions = dependencies.actions;

  _sourceQueue.default.initialize(actions);

  debuggerClient.mainRoot.on("processListChanged", threadListChanged);
  workersListener = new WorkersListener(debuggerClient.mainRoot);
  threadFrontListeners = new WeakMap();
}

function setupEventsTopTarget(targetFront) {
  targetFront.on("workerListChanged", threadListChanged);
  addThreadEventListeners(targetFront.threadFront);

  if (_prefs.features.windowlessServiceWorkers || attachAllTargets(targetFront)) {
    workersListener.addListener(threadListChanged);
  }
}

function removeEventsTopTarget(targetFront) {
  targetFront.off("workerListChanged", threadListChanged);
  removeThreadEventListeners(targetFront.threadFront);
  workersListener.removeListener();
}

async function paused(threadFront, packet) {
  // When reloading we might get pauses from threads before they have been
  // added to the store. Ensure the pause won't be processed until we've
  // finished adding the thread.
  await actions.ensureHasThread(threadFront.actor); // If paused by an explicit interrupt, which are generated by the
  // slow script dialog and internal events such as setting
  // breakpoints, ignore the event.

  const {
    why
  } = packet;

  if (why.type === "interrupted" && !packet.why.onNext) {
    isInterrupted = true;
    return;
  }

  if (why.type == "alreadyPaused") {
    return;
  }

  if (packet.frame) {
    // When reloading we might receive a pause event before the
    // top frame's source has arrived.
    await actions.ensureSourceActor(threadFront.actorID, packet.frame.where.actor);
  }

  const pause = (0, _create.createPause)(threadFront.actor, packet);
  actions.paused(pause);
  (0, _telemetry.recordEvent)("pause", {
    reason: why.type
  });
}

function resumed(threadFront) {
  // NOTE: the client suppresses resumed events while interrupted
  // to prevent unintentional behavior.
  // see [client docs](../README.md#interrupted) for more information.
  if (isInterrupted) {
    isInterrupted = false;
    return;
  }

  actions.resumed(threadFront.actorID);
}

function newSource(threadFront, {
  source
}) {
  _sourceQueue.default.queue({
    type: "generated",
    data: (0, _create.prepareSourcePayload)(threadFront, source)
  });
}

function threadListChanged() {
  actions.updateThreads();
}

function replayFramePositions(threadFront, {
  positions,
  frame,
  thread
}) {
  actions.setFramePositions(positions, frame, thread);
}

const clientEvents = {
  paused,
  resumed,
  newSource,
  replayFramePositions
};
exports.clientEvents = clientEvents;